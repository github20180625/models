java的内存机制:
    基本概念:在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台
    和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定
    了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行
    性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器
    对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。
java语言的原子性、可见性、有序性：
1.原子性:在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作:
        即这些操作是不可被中断的，要么执行，要么不执行。
解决方案：Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，
        可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻
        只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

2.可见性:而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，
    当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
解决方案：通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻
        只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。
        因此可以保证可见性。另外使用关键字volatile也可以保证党变量的值发生改变时，立即将值
        刷新到主存中去。
3.有序性:在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，
    却会影响到多线程并发执行的正确性。
解决方案：通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，
        很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行
        同步代码，自然就保证了有序性。
     　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，
        这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，
        那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。




volatile关键字的特点:当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，
                   当有其他线程需要读取时，它会去内存中读取新值。
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对
        其他线程来说是立即可见的。
　　2）禁止进行指令重排序。

使用volatile的原理和实现的机制:加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，
    加入volatile关键字时，会多出一个lock前缀指令;
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：
1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；
    即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
2）它会强制将对缓存的修改操作立即写入主存；
3）如果是写操作，它会导致其他CPU中对应的缓存行无效。
备注(说明):
但是volatile是不能保存程序执行时的原子性的,也就是说在多线程中,如果使用volatile是
    有可能出现错误的